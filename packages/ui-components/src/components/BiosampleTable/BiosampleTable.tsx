import { capitalize } from "@mui/material";
import Table from "../Table/Table";
import { ccreBedUrlCol, columns as defaultCols } from "./columns";
import { BiosampleTableProps, EncodeBiosample } from "./types";
import { useEncodeBiosampleData } from "./useEncodeBiosampleData";
import { JSX, useEffect, useMemo } from "react";
import { DataGridPremiumProps, getGroupRowIdFromPath, GridApiPremium, GridColDef, gridDataRowIdsSelector, gridFilteredSortedRowEntriesSelector, GridGroupingColDefOverride, GridRowId, gridRowNodeSelector, gridRowsLookupSelector, gridRowsMetaSelector, gridSortedRowEntriesSelector, gridVisibleRowsSelector, isAutogeneratedRow, useGridApiRef } from "@mui/x-data-grid-premium";
import { GridInitialStatePremium } from "@mui/x-data-grid-premium/models/gridStatePremium";

/**
 * This intentionally lists all columns in the visibility model (even visible cols) so that consumers can import and print it out to see all the keys
 * Can also use `allColsHidden` which is an object of all column fields set to false, which you can spread and then override the visible cols in initialState
 */
export const initialTableState: GridInitialStatePremium = {
  rowGrouping: { model: ["ontology"] },
  sorting: { sortModel: [{ field: "collection", sort: "asc" } as const] },
  columns: {
    columnVisibilityModel: {
      displayname: false, //only false since it is used as "leafField" in groupingColDef
      assays: true,
      ontology: true,
      sampleType: false,
      lifeStage: false,
      bedurl: false,
      bigbedurl: false,
      dnase_experiment_accession: false,
      dnase_file_accession: false,
      dnaseZ: false,
      dnase_signal_url: false,
      atac_experiment_accession: false,
      atac_file_accession: false,
      atacZ: false,
      atac_signal_url: false,
      h3k4me3_experiment_accession: false,
      h3k4me3_file_accession: false,
      h3k4me3Z: false,
      h3k4me3_signal_url: false,
      h3k27ac_experiment_accession: false,
      h3k27ac_file_accession: false,
      h3k27acZ: false,
      h3k27ac_signal_url: false,
      ctcf_experiment_accession: false,
      ctcf_file_accession: false,
      ctcfZ: false,
      ctcf_signal_url: false,
      chromhmm_url: false,
      rnaSeq: false,
    },
  },
  filter: {
    filterModel: {
      items: [],
      quickFilterExcludeHiddenColumns: false,
    }
  }
};

const groupingColDef:  GridGroupingColDefOverride<any> = { leafField: "displayname", headerName: 'Tissue/Biosample', maxWidth: 400, display: "flex", valueFormatter: (value) => capitalize(value) } as const

/**
 * 
 * @param apiRef 
 * @param ids 
 * This function is used to add autogenerated row Ids to the list of selected Ids if all children are selected.
 * It is needed so that select/unselect all checkboxes can work properly without passing in the autogenerated row IDs from outside the components.
 * It will add the grouping row ID only if all children are selected
 */
const addAutogeneratedRowIdsToChildren = (
  apiRef: React.RefObject<GridApiPremium | null>,
  selected: GridRowId[]
): Set<GridRowId> => {
  const autogeneratedRows = gridFilteredSortedRowEntriesSelector(apiRef).filter((entry) =>
    isAutogeneratedRow(entry.model)
  );

  const autogeneratedIdsToAdd = autogeneratedRows
    .filter((row) => {
      const children = apiRef.current?.getRowGroupChildren({ groupId: row.id, applyFiltering: true });
      const allChildrenSelected = children?.every((id) => selected?.includes(id));
      return allChildrenSelected;
    })
    .map((x) => x.id);

  console.log(autogeneratedIdsToAdd)

  return new Set([...selected, ...autogeneratedIdsToAdd]);
};

export function BiosampleTable(props: BiosampleTableProps): JSX.Element {
  const {
    data: encodeSamples,
    loading: encodeLoading,
    error: encodeError,
  } = useEncodeBiosampleData({ assembly: props.assembly, skip: props.rows !== undefined });

  const {
    loading,
    error,
    assembly, //custom added prop
    rows = encodeSamples ?? [],
    prefilterBiosamples = () => true, //custom added prop
    columns = defaultCols,
    label = "Biosamples",
    downloadFileName = "Biosamples",
    initialState = initialTableState,
    onSelectionChange = (selected: EncodeBiosample[]) => null, //custom added prop
    onRowSelectionModelChange, //have to extract here or else overrides to it would break the onSelectionChange functionality
    apiRef: externalApiRef,
    selected = undefined,
    getRowId = (x: EncodeBiosample) => x.name,
    ...restProps
  } = props;

  const internalApiRef = useGridApiRef();
  // prioritize using the provided apiRef if available, otherwise create a new one
  const apiRef = externalApiRef ?? internalApiRef;

  const internalRows = rows.filter(prefilterBiosamples);

  const handleSelection: DataGridPremiumProps["onRowSelectionModelChange"] = (rowSelectionModel, details) => {
    if (onRowSelectionModelChange) onRowSelectionModelChange(rowSelectionModel, details);
    // we are passing disableRowSelectionExcludeModel, so should always be using "include"
    onSelectionChange(internalRows.filter((row) => rowSelectionModel.ids.has(getRowId(row))));
  };

  const internalFlexColumns: GridColDef[] = columns.map(x => ({...x, display: "flex"}))
  
  const rowSelectionModel = useMemo(() => {
    if (!selected || !apiRef.current) return undefined
    return {type: "include", ids: addAutogeneratedRowIdsToChildren(apiRef, selected)} as const
  }, [selected])

  return (
    <Table
      apiRef={apiRef}
      label={label}
      downloadFileName={downloadFileName}
      rows={internalRows}
      columns={internalFlexColumns}
      loading={loading || encodeLoading}
      error={error || encodeError}
      initialState={initialState}
      rowSelectionPropagation={{ descendants: true }}
      rowSelectionModel={rowSelectionModel}
      groupingColDef={groupingColDef}
      getRowId={getRowId}
      getRowHeight={() => "auto"}
      onRowSelectionModelChange={handleSelection}
      disableRowSelectionExcludeModel // forces only using "include" model for easier mapping
      keepNonExistentRowsSelected
      {...restProps}
    />
  );
}
